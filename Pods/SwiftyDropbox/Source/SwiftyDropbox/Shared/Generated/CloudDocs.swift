///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Datatypes and serializers for the cloud_docs namespace
open class CloudDocs {
    /// The CloudDocsAccessError union
    public enum CloudDocsAccessError: CustomStringConvertible {
        /// The Cloud Doc ID is invalid.
        case invalidDocId
        /// A Cloud Doc could not be found for the given ID.
        case notFound
        /// Permission denied for the Cloud Doc with the given ID.
        case permissionDenied
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(CloudDocsAccessErrorSerializer().serialize(self)))"
        }
    }
    open class CloudDocsAccessErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: CloudDocsAccessError) -> JSON {
            switch value {
                case .invalidDocId:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_doc_id")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .permissionDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .str("permission_denied")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> CloudDocsAccessError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_doc_id":
                            return CloudDocsAccessError.invalidDocId
                        case "not_found":
                            return CloudDocsAccessError.notFound
                        case "permission_denied":
                            return CloudDocsAccessError.permissionDenied
                        case "other":
                            return CloudDocsAccessError.other
                        default:
                            return CloudDocsAccessError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The Content struct
    open class Content: CustomStringConvertible {
        /// (no description)
        public let purpose: CloudDocs.ContentPurpose
        /// The key returned from an upload_additional_content response.
        public let contentKey: String
        public init(purpose: CloudDocs.ContentPurpose, contentKey: String) {
            self.purpose = purpose
            stringValidator()(contentKey)
            self.contentKey = contentKey
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ContentSerializer().serialize(self)))"
        }
    }
    open class ContentSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: Content) -> JSON {
            let output = [ 
            "purpose": CloudDocs.ContentPurposeSerializer().serialize(value.purpose),
            "content_key": Serialization._StringSerializer.serialize(value.contentKey),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> Content {
            switch json {
                case .dictionary(let dict):
                    let purpose = CloudDocs.ContentPurposeSerializer().deserialize(dict["purpose"] ?? .null)
                    let contentKey = Serialization._StringSerializer.deserialize(dict["content_key"] ?? .null)
                    return Content(purpose: purpose, contentKey: contentKey)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The ContentPurpose union
    public enum ContentPurpose: CustomStringConvertible {
        /// An unspecified error.
        case search
        /// An unspecified error.
        case preview
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(ContentPurposeSerializer().serialize(self)))"
        }
    }
    open class ContentPurposeSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: ContentPurpose) -> JSON {
            switch value {
                case .search:
                    var d = [String: JSON]()
                    d[".tag"] = .str("search")
                    return .dictionary(d)
                case .preview:
                    var d = [String: JSON]()
                    d[".tag"] = .str("preview")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> ContentPurpose {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "search":
                            return ContentPurpose.search
                        case "preview":
                            return ContentPurpose.preview
                        case "other":
                            return ContentPurpose.other
                        default:
                            return ContentPurpose.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GenericErrorTag union
    public enum GenericErrorTag: CustomStringConvertible {
        /// Invalid argument supplied.
        case invalidArgument
        /// User is unauthenticated.
        case unauthenticated
        /// User does not have access to the specified doc.
        case permissionDenied
        /// Doc could not be found based on the supplied doc ID.
        case docNotFound
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GenericErrorTagSerializer().serialize(self)))"
        }
    }
    open class GenericErrorTagSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GenericErrorTag) -> JSON {
            switch value {
                case .invalidArgument:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_argument")
                    return .dictionary(d)
                case .unauthenticated:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unauthenticated")
                    return .dictionary(d)
                case .permissionDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .str("permission_denied")
                    return .dictionary(d)
                case .docNotFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("doc_not_found")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GenericErrorTag {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_argument":
                            return GenericErrorTag.invalidArgument
                        case "unauthenticated":
                            return GenericErrorTag.unauthenticated
                        case "permission_denied":
                            return GenericErrorTag.permissionDenied
                        case "doc_not_found":
                            return GenericErrorTag.docNotFound
                        case "other":
                            return GenericErrorTag.other
                        default:
                            return GenericErrorTag.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The GetContentArg struct
    open class GetContentArg: CustomStringConvertible {
        /// (no description)
        public let fileId: String
        public init(fileId: String) {
            stringValidator(minLength: 4, pattern: "id:.+")(fileId)
            self.fileId = fileId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetContentArgSerializer().serialize(self)))"
        }
    }
    open class GetContentArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetContentArg) -> JSON {
            let output = [ 
            "file_id": Serialization._StringSerializer.serialize(value.fileId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetContentArg {
            switch json {
                case .dictionary(let dict):
                    let fileId = Serialization._StringSerializer.deserialize(dict["file_id"] ?? .null)
                    return GetContentArg(fileId: fileId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetMetadataArg struct
    open class GetMetadataArg: CustomStringConvertible {
        /// API ID ("id:...") associated with the Cloud Doc.
        public let fileId: String
        public init(fileId: String = "") {
            stringValidator()(fileId)
            self.fileId = fileId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetMetadataArgSerializer().serialize(self)))"
        }
    }
    open class GetMetadataArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetMetadataArg) -> JSON {
            let output = [ 
            "file_id": Serialization._StringSerializer.serialize(value.fileId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetMetadataArg {
            switch json {
                case .dictionary(let dict):
                    let fileId = Serialization._StringSerializer.deserialize(dict["file_id"] ?? .str(""))
                    return GetMetadataArg(fileId: fileId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetMetadataError struct
    open class GetMetadataError: CustomStringConvertible {
        /// (no description)
        public let getMetadataErrorTag: CloudDocs.GetMetadataErrorTagUnion?
        public init(getMetadataErrorTag: CloudDocs.GetMetadataErrorTagUnion? = nil) {
            self.getMetadataErrorTag = getMetadataErrorTag
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetMetadataErrorSerializer().serialize(self)))"
        }
    }
    open class GetMetadataErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetMetadataError) -> JSON {
            let output = [ 
            "get_metadata_error_tag": NullableSerializer(CloudDocs.GetMetadataErrorTagUnionSerializer()).serialize(value.getMetadataErrorTag),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetMetadataError {
            switch json {
                case .dictionary(let dict):
                    let getMetadataErrorTag = NullableSerializer(CloudDocs.GetMetadataErrorTagUnionSerializer()).deserialize(dict["get_metadata_error_tag"] ?? .null)
                    return GetMetadataError(getMetadataErrorTag: getMetadataErrorTag)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetMetadataResult struct
    open class GetMetadataResult: CustomStringConvertible {
        /// (no description)
        public let fileId: String
        /// Title of the Cloud Doc without extension.
        public let title: String
        /// MIME type of the Cloud Doc.
        public let mimeType: String
        /// Opaque string representing the version of the document stored in Dropbox (only set for Dropbox-stored
        /// Documents).
        public let version: String
        /// Application specific string representing the revision of a document (only set for App-stored Documents).
        public let providerVersion: String
        /// User identified by the auth token.
        public let user: CloudDocs.UserInfo?
        /// true if the document is deleted or purged.
        public let isDeleted: Bool
        /// Actions that the user identified by the auth token can performn. This message will not be populated for
        /// deleted documents.
        public let userPermissions: CloudDocs.UserPermissions?
        public init(fileId: String = "", title: String = "", mimeType: String = "", version: String = "", providerVersion: String = "", user: CloudDocs.UserInfo? = nil, isDeleted: Bool = false, userPermissions: CloudDocs.UserPermissions? = nil) {
            stringValidator()(fileId)
            self.fileId = fileId
            stringValidator()(title)
            self.title = title
            stringValidator()(mimeType)
            self.mimeType = mimeType
            stringValidator()(version)
            self.version = version
            stringValidator()(providerVersion)
            self.providerVersion = providerVersion
            self.user = user
            self.isDeleted = isDeleted
            self.userPermissions = userPermissions
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetMetadataResultSerializer().serialize(self)))"
        }
    }
    open class GetMetadataResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetMetadataResult) -> JSON {
            let output = [ 
            "file_id": Serialization._StringSerializer.serialize(value.fileId),
            "title": Serialization._StringSerializer.serialize(value.title),
            "mime_type": Serialization._StringSerializer.serialize(value.mimeType),
            "version": Serialization._StringSerializer.serialize(value.version),
            "provider_version": Serialization._StringSerializer.serialize(value.providerVersion),
            "user": NullableSerializer(CloudDocs.UserInfoSerializer()).serialize(value.user),
            "is_deleted": Serialization._BoolSerializer.serialize(value.isDeleted),
            "user_permissions": NullableSerializer(CloudDocs.UserPermissionsSerializer()).serialize(value.userPermissions),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> GetMetadataResult {
            switch json {
                case .dictionary(let dict):
                    let fileId = Serialization._StringSerializer.deserialize(dict["file_id"] ?? .str(""))
                    let title = Serialization._StringSerializer.deserialize(dict["title"] ?? .str(""))
                    let mimeType = Serialization._StringSerializer.deserialize(dict["mime_type"] ?? .str(""))
                    let version = Serialization._StringSerializer.deserialize(dict["version"] ?? .str(""))
                    let providerVersion = Serialization._StringSerializer.deserialize(dict["provider_version"] ?? .str(""))
                    let user = NullableSerializer(CloudDocs.UserInfoSerializer()).deserialize(dict["user"] ?? .null)
                    let isDeleted = Serialization._BoolSerializer.deserialize(dict["is_deleted"] ?? .number(0))
                    let userPermissions = NullableSerializer(CloudDocs.UserPermissionsSerializer()).deserialize(dict["user_permissions"] ?? .null)
                    return GetMetadataResult(fileId: fileId, title: title, mimeType: mimeType, version: version, providerVersion: providerVersion, user: user, isDeleted: isDeleted, userPermissions: userPermissions)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LockArg struct
    open class LockArg: CustomStringConvertible {
        /// The API ID ("id:...") associated with the Cloud Doc
        public let fileId: String
        public init(fileId: String = "") {
            stringValidator()(fileId)
            self.fileId = fileId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LockArgSerializer().serialize(self)))"
        }
    }
    open class LockArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LockArg) -> JSON {
            let output = [ 
            "file_id": Serialization._StringSerializer.serialize(value.fileId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LockArg {
            switch json {
                case .dictionary(let dict):
                    let fileId = Serialization._StringSerializer.deserialize(dict["file_id"] ?? .str(""))
                    return LockArg(fileId: fileId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LockResult struct
    open class LockResult: CustomStringConvertible {
        /// (no description)
        public let fileId: String
        /// The timestamp after which the lock will expire, measured in seconds since 1970-01-01 00:00:00 UTC
        public let expiresAt: Int64
        public init(fileId: String = "", expiresAt: Int64 = 0) {
            stringValidator()(fileId)
            self.fileId = fileId
            comparableValidator()(expiresAt)
            self.expiresAt = expiresAt
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LockResultSerializer().serialize(self)))"
        }
    }
    open class LockResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LockResult) -> JSON {
            let output = [ 
            "file_id": Serialization._StringSerializer.serialize(value.fileId),
            "expires_at": Serialization._Int64Serializer.serialize(value.expiresAt),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LockResult {
            switch json {
                case .dictionary(let dict):
                    let fileId = Serialization._StringSerializer.deserialize(dict["file_id"] ?? .str(""))
                    let expiresAt = Serialization._Int64Serializer.deserialize(dict["expires_at"] ?? .number(0))
                    return LockResult(fileId: fileId, expiresAt: expiresAt)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LockingError struct
    open class LockingError: CustomStringConvertible {
        /// (no description)
        public let lockingErrorTag: CloudDocs.LockingErrorTagUnion?
        public init(lockingErrorTag: CloudDocs.LockingErrorTagUnion? = nil) {
            self.lockingErrorTag = lockingErrorTag
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LockingErrorSerializer().serialize(self)))"
        }
    }
    open class LockingErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LockingError) -> JSON {
            let output = [ 
            "locking_error_tag": NullableSerializer(CloudDocs.LockingErrorTagUnionSerializer()).serialize(value.lockingErrorTag),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> LockingError {
            switch json {
                case .dictionary(let dict):
                    let lockingErrorTag = NullableSerializer(CloudDocs.LockingErrorTagUnionSerializer()).deserialize(dict["locking_error_tag"] ?? .null)
                    return LockingError(lockingErrorTag: lockingErrorTag)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The LockingErrorTag union
    public enum LockingErrorTag: CustomStringConvertible {
        /// A lock on the doc is held by another editor
        case conflict
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LockingErrorTagSerializer().serialize(self)))"
        }
    }
    open class LockingErrorTagSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LockingErrorTag) -> JSON {
            switch value {
                case .conflict:
                    var d = [String: JSON]()
                    d[".tag"] = .str("conflict")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LockingErrorTag {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "conflict":
                            return LockingErrorTag.conflict
                        case "other":
                            return LockingErrorTag.other
                        default:
                            return LockingErrorTag.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RenameArg struct
    open class RenameArg: CustomStringConvertible {
        /// The API ID ("id:...") associated with the Cloud Doc
        public let fileId: String
        /// The new title of the doc, excluding extension
        public let title: String
        public init(fileId: String = "", title: String = "") {
            stringValidator()(fileId)
            self.fileId = fileId
            stringValidator()(title)
            self.title = title
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RenameArgSerializer().serialize(self)))"
        }
    }
    open class RenameArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RenameArg) -> JSON {
            let output = [ 
            "file_id": Serialization._StringSerializer.serialize(value.fileId),
            "title": Serialization._StringSerializer.serialize(value.title),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RenameArg {
            switch json {
                case .dictionary(let dict):
                    let fileId = Serialization._StringSerializer.deserialize(dict["file_id"] ?? .str(""))
                    let title = Serialization._StringSerializer.deserialize(dict["title"] ?? .str(""))
                    return RenameArg(fileId: fileId, title: title)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RenameError struct
    open class RenameError: CustomStringConvertible {
        /// (no description)
        public let renameErrorTag: CloudDocs.RenameErrorTagUnion?
        public init(renameErrorTag: CloudDocs.RenameErrorTagUnion? = nil) {
            self.renameErrorTag = renameErrorTag
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RenameErrorSerializer().serialize(self)))"
        }
    }
    open class RenameErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RenameError) -> JSON {
            let output = [ 
            "rename_error_tag": NullableSerializer(CloudDocs.RenameErrorTagUnionSerializer()).serialize(value.renameErrorTag),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RenameError {
            switch json {
                case .dictionary(let dict):
                    let renameErrorTag = NullableSerializer(CloudDocs.RenameErrorTagUnionSerializer()).deserialize(dict["rename_error_tag"] ?? .null)
                    return RenameError(renameErrorTag: renameErrorTag)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The RenameErrorTag union
    public enum RenameErrorTag: CustomStringConvertible {
        /// The supplied title is invalid, e.g. the length of the title is longer than max length (255 characters); the
        /// title contains illegal characters.
        case invalidTitle
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RenameErrorTagSerializer().serialize(self)))"
        }
    }
    open class RenameErrorTagSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RenameErrorTag) -> JSON {
            switch value {
                case .invalidTitle:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_title")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RenameErrorTag {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_title":
                            return RenameErrorTag.invalidTitle
                        case "other":
                            return RenameErrorTag.other
                        default:
                            return RenameErrorTag.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RenameResult struct
    open class RenameResult: CustomStringConvertible {
        /// The updated title of the doc without extension, which could be different from the supplied title in the
        /// request because Dropbox may remove/replace charaters that are not supported in Dropbox Filesystem.
        public let title: String
        public init(title: String = "") {
            stringValidator()(title)
            self.title = title
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RenameResultSerializer().serialize(self)))"
        }
    }
    open class RenameResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RenameResult) -> JSON {
            let output = [ 
            "title": Serialization._StringSerializer.serialize(value.title),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> RenameResult {
            switch json {
                case .dictionary(let dict):
                    let title = Serialization._StringSerializer.deserialize(dict["title"] ?? .str(""))
                    return RenameResult(title: title)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UnlockArg struct
    open class UnlockArg: CustomStringConvertible {
        /// The API ID ("id:...") associated with the Cloud Doc
        public let fileId: String
        public init(fileId: String = "") {
            stringValidator()(fileId)
            self.fileId = fileId
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnlockArgSerializer().serialize(self)))"
        }
    }
    open class UnlockArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UnlockArg) -> JSON {
            let output = [ 
            "file_id": Serialization._StringSerializer.serialize(value.fileId),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UnlockArg {
            switch json {
                case .dictionary(let dict):
                    let fileId = Serialization._StringSerializer.deserialize(dict["file_id"] ?? .str(""))
                    return UnlockArg(fileId: fileId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// Empty message for unlock
    open class UnlockResult: CustomStringConvertible {
        public init() {
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UnlockResultSerializer().serialize(self)))"
        }
    }
    open class UnlockResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UnlockResult) -> JSON {
            let output = [String: JSON]()
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UnlockResult {
            switch json {
                case .dictionary(_):
                    return UnlockResult()
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UpdateContentArg struct
    open class UpdateContentArg: CustomStringConvertible {
        /// (no description)
        public let fileId: String
        /// A list of auth_tokens, one for each editor who made changes to the document since the last call to
        /// update_content.
        public let actorTokens: Array<String>
        /// Currently, this will always be empty until we implement upload_additional_content.
        public let additionalContents: Array<CloudDocs.Content>?
        public init(fileId: String, actorTokens: Array<String>, additionalContents: Array<CloudDocs.Content>? = nil) {
            stringValidator(minLength: 4, pattern: "id:.+")(fileId)
            self.fileId = fileId
            arrayValidator(itemValidator: stringValidator())(actorTokens)
            self.actorTokens = actorTokens
            self.additionalContents = additionalContents
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateContentArgSerializer().serialize(self)))"
        }
    }
    open class UpdateContentArgSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateContentArg) -> JSON {
            let output = [ 
            "file_id": Serialization._StringSerializer.serialize(value.fileId),
            "actor_tokens": ArraySerializer(Serialization._StringSerializer).serialize(value.actorTokens),
            "additional_contents": NullableSerializer(ArraySerializer(CloudDocs.ContentSerializer())).serialize(value.additionalContents),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UpdateContentArg {
            switch json {
                case .dictionary(let dict):
                    let fileId = Serialization._StringSerializer.deserialize(dict["file_id"] ?? .null)
                    let actorTokens = ArraySerializer(Serialization._StringSerializer).deserialize(dict["actor_tokens"] ?? .null)
                    let additionalContents = NullableSerializer(ArraySerializer(CloudDocs.ContentSerializer())).deserialize(dict["additional_contents"] ?? .null)
                    return UpdateContentArg(fileId: fileId, actorTokens: actorTokens, additionalContents: additionalContents)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UpdateContentError union
    public enum UpdateContentError: CustomStringConvertible {
        /// The Cloud Doc ID is invalid.
        case invalidDocId
        /// A Cloud Doc could not be found for the given ID.
        case notFound
        /// Permission denied for the Cloud Doc with the given ID.
        case permissionDenied
        /// An unspecified error.
        case other
        /// Upload payload exceeds maximum allowed size of 150MB.
        case uploadSizeTooLarge
        /// A lock on the document identified by path_or_id is held by another editor.
        case conflict
        /// A lock is not held on the document identified by path_or_id. Acquire lock before uploading content for the
        /// document.
        case unlocked

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateContentErrorSerializer().serialize(self)))"
        }
    }
    open class UpdateContentErrorSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateContentError) -> JSON {
            switch value {
                case .invalidDocId:
                    var d = [String: JSON]()
                    d[".tag"] = .str("invalid_doc_id")
                    return .dictionary(d)
                case .notFound:
                    var d = [String: JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .permissionDenied:
                    var d = [String: JSON]()
                    d[".tag"] = .str("permission_denied")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
                case .uploadSizeTooLarge:
                    var d = [String: JSON]()
                    d[".tag"] = .str("upload_size_too_large")
                    return .dictionary(d)
                case .conflict:
                    var d = [String: JSON]()
                    d[".tag"] = .str("conflict")
                    return .dictionary(d)
                case .unlocked:
                    var d = [String: JSON]()
                    d[".tag"] = .str("unlocked")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> UpdateContentError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "invalid_doc_id":
                            return UpdateContentError.invalidDocId
                        case "not_found":
                            return UpdateContentError.notFound
                        case "permission_denied":
                            return UpdateContentError.permissionDenied
                        case "other":
                            return UpdateContentError.other
                        case "upload_size_too_large":
                            return UpdateContentError.uploadSizeTooLarge
                        case "conflict":
                            return UpdateContentError.conflict
                        case "unlocked":
                            return UpdateContentError.unlocked
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The UpdateContentResult struct
    open class UpdateContentResult: CustomStringConvertible {
        /// Version of the document stored in Dropbox.
        public let version: String
        public init(version: String) {
            stringValidator()(version)
            self.version = version
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UpdateContentResultSerializer().serialize(self)))"
        }
    }
    open class UpdateContentResultSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UpdateContentResult) -> JSON {
            let output = [ 
            "version": Serialization._StringSerializer.serialize(value.version),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UpdateContentResult {
            switch json {
                case .dictionary(let dict):
                    let version = Serialization._StringSerializer.deserialize(dict["version"] ?? .null)
                    return UpdateContentResult(version: version)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UserInfo struct
    open class UserInfo: CustomStringConvertible {
        /// ID associated with the user.
        public let id: String
        /// Email associated with the user.
        public let email: String
        public init(id: String = "", email: String = "") {
            stringValidator()(id)
            self.id = id
            stringValidator()(email)
            self.email = email
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserInfoSerializer().serialize(self)))"
        }
    }
    open class UserInfoSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserInfo) -> JSON {
            let output = [ 
            "id": Serialization._StringSerializer.serialize(value.id),
            "email": Serialization._StringSerializer.serialize(value.email),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserInfo {
            switch json {
                case .dictionary(let dict):
                    let id = Serialization._StringSerializer.deserialize(dict["id"] ?? .str(""))
                    let email = Serialization._StringSerializer.deserialize(dict["email"] ?? .str(""))
                    return UserInfo(id: id, email: email)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The UserPermissions struct
    open class UserPermissions: CustomStringConvertible {
        /// true if the user can edit the content of this document
        public let canEdit: Bool
        /// true if the user can edit the title of this document
        public let canRename: Bool
        /// true if the user can comment on this document
        public let canComment: Bool
        /// true if the user can download the contents of this document. currently always true if the user has view
        /// access to the document.
        public let canDownload: Bool
        public init(canEdit: Bool = false, canRename: Bool = false, canComment: Bool = false, canDownload: Bool = false) {
            self.canEdit = canEdit
            self.canRename = canRename
            self.canComment = canComment
            self.canDownload = canDownload
        }
        open var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(UserPermissionsSerializer().serialize(self)))"
        }
    }
    open class UserPermissionsSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: UserPermissions) -> JSON {
            let output = [ 
            "can_edit": Serialization._BoolSerializer.serialize(value.canEdit),
            "can_rename": Serialization._BoolSerializer.serialize(value.canRename),
            "can_comment": Serialization._BoolSerializer.serialize(value.canComment),
            "can_download": Serialization._BoolSerializer.serialize(value.canDownload),
            ]
            return .dictionary(output)
        }
        open func deserialize(_ json: JSON) -> UserPermissions {
            switch json {
                case .dictionary(let dict):
                    let canEdit = Serialization._BoolSerializer.deserialize(dict["can_edit"] ?? .number(0))
                    let canRename = Serialization._BoolSerializer.deserialize(dict["can_rename"] ?? .number(0))
                    let canComment = Serialization._BoolSerializer.deserialize(dict["can_comment"] ?? .number(0))
                    let canDownload = Serialization._BoolSerializer.deserialize(dict["can_download"] ?? .number(0))
                    return UserPermissions(canEdit: canEdit, canRename: canRename, canComment: canComment, canDownload: canDownload)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }

    /// The GetMetadataErrorTagUnion union
    public enum GetMetadataErrorTagUnion: CustomStringConvertible {
        /// An unspecified error.
        case genericError(CloudDocs.GenericErrorTag)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(GetMetadataErrorTagUnionSerializer().serialize(self)))"
        }
    }
    open class GetMetadataErrorTagUnionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: GetMetadataErrorTagUnion) -> JSON {
            switch value {
                case .genericError(let arg):
                    var d = ["generic_error": CloudDocs.GenericErrorTagSerializer().serialize(arg)]
                    d[".tag"] = .str("generic_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> GetMetadataErrorTagUnion {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "generic_error":
                            let v = CloudDocs.GenericErrorTagSerializer().deserialize(d["generic_error"] ?? .null)
                            return GetMetadataErrorTagUnion.genericError(v)
                        case "other":
                            return GetMetadataErrorTagUnion.other
                        default:
                            return GetMetadataErrorTagUnion.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The LockingErrorTagUnion union
    public enum LockingErrorTagUnion: CustomStringConvertible {
        /// An unspecified error.
        case lockingError(CloudDocs.LockingErrorTag)
        /// An unspecified error.
        case genericError(CloudDocs.GenericErrorTag)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(LockingErrorTagUnionSerializer().serialize(self)))"
        }
    }
    open class LockingErrorTagUnionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: LockingErrorTagUnion) -> JSON {
            switch value {
                case .lockingError(let arg):
                    var d = ["locking_error": CloudDocs.LockingErrorTagSerializer().serialize(arg)]
                    d[".tag"] = .str("locking_error")
                    return .dictionary(d)
                case .genericError(let arg):
                    var d = ["generic_error": CloudDocs.GenericErrorTagSerializer().serialize(arg)]
                    d[".tag"] = .str("generic_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> LockingErrorTagUnion {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "locking_error":
                            let v = CloudDocs.LockingErrorTagSerializer().deserialize(d["locking_error"] ?? .null)
                            return LockingErrorTagUnion.lockingError(v)
                        case "generic_error":
                            let v = CloudDocs.GenericErrorTagSerializer().deserialize(d["generic_error"] ?? .null)
                            return LockingErrorTagUnion.genericError(v)
                        case "other":
                            return LockingErrorTagUnion.other
                        default:
                            return LockingErrorTagUnion.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }

    /// The RenameErrorTagUnion union
    public enum RenameErrorTagUnion: CustomStringConvertible {
        /// An unspecified error.
        case renameError(CloudDocs.RenameErrorTag)
        /// An unspecified error.
        case genericError(CloudDocs.GenericErrorTag)
        /// An unspecified error.
        case lockingError(CloudDocs.LockingErrorTag)
        /// An unspecified error.
        case other

        public var description: String {
            return "\(SerializeUtil.prepareJSONForSerialization(RenameErrorTagUnionSerializer().serialize(self)))"
        }
    }
    open class RenameErrorTagUnionSerializer: JSONSerializer {
        public init() { }
        open func serialize(_ value: RenameErrorTagUnion) -> JSON {
            switch value {
                case .renameError(let arg):
                    var d = ["rename_error": CloudDocs.RenameErrorTagSerializer().serialize(arg)]
                    d[".tag"] = .str("rename_error")
                    return .dictionary(d)
                case .genericError(let arg):
                    var d = ["generic_error": CloudDocs.GenericErrorTagSerializer().serialize(arg)]
                    d[".tag"] = .str("generic_error")
                    return .dictionary(d)
                case .lockingError(let arg):
                    var d = ["locking_error": CloudDocs.LockingErrorTagSerializer().serialize(arg)]
                    d[".tag"] = .str("locking_error")
                    return .dictionary(d)
                case .other:
                    var d = [String: JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        open func deserialize(_ json: JSON) -> RenameErrorTagUnion {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "rename_error":
                            let v = CloudDocs.RenameErrorTagSerializer().deserialize(d["rename_error"] ?? .null)
                            return RenameErrorTagUnion.renameError(v)
                        case "generic_error":
                            let v = CloudDocs.GenericErrorTagSerializer().deserialize(d["generic_error"] ?? .null)
                            return RenameErrorTagUnion.genericError(v)
                        case "locking_error":
                            let v = CloudDocs.LockingErrorTagSerializer().deserialize(d["locking_error"] ?? .null)
                            return RenameErrorTagUnion.lockingError(v)
                        case "other":
                            return RenameErrorTagUnion.other
                        default:
                            return RenameErrorTagUnion.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }


    /// Stone Route Objects

    static let getContent = Route(
        name: "get_content",
        version: 1,
        namespace: "cloud_docs",
        deprecated: false,
        argSerializer: CloudDocs.GetContentArgSerializer(),
        responseSerializer: Serialization._VoidSerializer,
        errorSerializer: CloudDocs.CloudDocsAccessErrorSerializer(),
        attrs: ["auth": "user",
                "host": "content",
                "style": "download"]
    )
    static let getMetadata = Route(
        name: "get_metadata",
        version: 1,
        namespace: "cloud_docs",
        deprecated: false,
        argSerializer: CloudDocs.GetMetadataArgSerializer(),
        responseSerializer: CloudDocs.GetMetadataResultSerializer(),
        errorSerializer: CloudDocs.GetMetadataErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let lock = Route(
        name: "lock",
        version: 1,
        namespace: "cloud_docs",
        deprecated: false,
        argSerializer: CloudDocs.LockArgSerializer(),
        responseSerializer: CloudDocs.LockResultSerializer(),
        errorSerializer: CloudDocs.LockingErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let rename = Route(
        name: "rename",
        version: 1,
        namespace: "cloud_docs",
        deprecated: false,
        argSerializer: CloudDocs.RenameArgSerializer(),
        responseSerializer: CloudDocs.RenameResultSerializer(),
        errorSerializer: CloudDocs.RenameErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let unlock = Route(
        name: "unlock",
        version: 1,
        namespace: "cloud_docs",
        deprecated: false,
        argSerializer: CloudDocs.UnlockArgSerializer(),
        responseSerializer: CloudDocs.UnlockResultSerializer(),
        errorSerializer: CloudDocs.LockingErrorSerializer(),
        attrs: ["auth": "user",
                "host": "api",
                "style": "rpc"]
    )
    static let updateContent = Route(
        name: "update_content",
        version: 1,
        namespace: "cloud_docs",
        deprecated: false,
        argSerializer: CloudDocs.UpdateContentArgSerializer(),
        responseSerializer: CloudDocs.UpdateContentResultSerializer(),
        errorSerializer: CloudDocs.UpdateContentErrorSerializer(),
        attrs: ["auth": "user",
                "host": "content",
                "style": "upload"]
    )
}

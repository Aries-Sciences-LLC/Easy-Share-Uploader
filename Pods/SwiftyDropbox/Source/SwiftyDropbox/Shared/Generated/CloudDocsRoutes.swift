///
/// Copyright (c) 2016 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation

/// Routes for the cloud_docs namespace
open class CloudDocsRoutes {
    public let client: DropboxTransportClient
    init(client: DropboxTransportClient) {
        self.client = client
    }

    /// Fetch the binary content of the requested document. This route requires Cloud Docs auth. Please make a request
    /// to cloud_docs/authorize and supply that token in the Authorization header.
    ///
    /// - parameter overwrite: A boolean to set behavior in the event of a naming conflict. `True` will overwrite
    /// conflicting file at destination. `False` will take no action (but if left unhandled in destination closure, an
    /// NSError will be thrown).
    /// - parameter destination: A closure used to compute the destination, given the temporary file location and the
    /// response.
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `CloudDocs.CloudDocsAccessError` object on failure.
    @discardableResult open func getContent(fileId: String, overwrite: Bool = false, destination: @escaping (URL, HTTPURLResponse) -> URL) -> DownloadRequestFile<VoidSerializer, CloudDocs.CloudDocsAccessErrorSerializer> {
        let route = CloudDocs.getContent
        let serverArgs = CloudDocs.GetContentArg(fileId: fileId)
        return client.request(route, serverArgs: serverArgs, overwrite: overwrite, destination: destination)
    }

    /// Fetch the binary content of the requested document. This route requires Cloud Docs auth. Please make a request
    /// to cloud_docs/authorize and supply that token in the Authorization header.
    ///
    ///
    ///  - returns: Through the response callback, the caller will receive a `Void` object on success or a
    /// `CloudDocs.CloudDocsAccessError` object on failure.
    @discardableResult open func getContent(fileId: String) -> DownloadRequestMemory<VoidSerializer, CloudDocs.CloudDocsAccessErrorSerializer> {
        let route = CloudDocs.getContent
        let serverArgs = CloudDocs.GetContentArg(fileId: fileId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Fetches metadata associated with a Cloud Doc and user. This route requires Cloud Docs auth. Please make a
    /// request to cloud_docs/authorize and supply that token in the Authorization header.
    ///
    /// - parameter fileId: API ID ("id:...") associated with the Cloud Doc.
    ///
    ///  - returns: Through the response callback, the caller will receive a `CloudDocs.GetMetadataResult` object on
    /// success or a `CloudDocs.GetMetadataError` object on failure.
    @discardableResult open func getMetadata(fileId: String = "") -> RpcRequest<CloudDocs.GetMetadataResultSerializer, CloudDocs.GetMetadataErrorSerializer> {
        let route = CloudDocs.getMetadata
        let serverArgs = CloudDocs.GetMetadataArg(fileId: fileId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Lock a Cloud Doc. This route requires Cloud Docs auth. Please make a request to cloud_docs/authorize and supply
    /// that token in the Authorization header.
    ///
    /// - parameter fileId: The API ID ("id:...") associated with the Cloud Doc
    ///
    ///  - returns: Through the response callback, the caller will receive a `CloudDocs.LockResult` object on success or
    /// a `CloudDocs.LockingError` object on failure.
    @discardableResult open func lock(fileId: String = "") -> RpcRequest<CloudDocs.LockResultSerializer, CloudDocs.LockingErrorSerializer> {
        let route = CloudDocs.lock
        let serverArgs = CloudDocs.LockArg(fileId: fileId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Update the title of a Cloud Doc. This route requires Cloud Docs auth. Please make a request to
    /// cloud_docs/authorize and supply that token in the Authorization header.
    ///
    /// - parameter fileId: The API ID ("id:...") associated with the Cloud Doc
    /// - parameter title: The new title of the doc, excluding extension
    ///
    ///  - returns: Through the response callback, the caller will receive a `CloudDocs.RenameResult` object on success
    /// or a `CloudDocs.RenameError` object on failure.
    @discardableResult open func rename(fileId: String = "", title: String = "") -> RpcRequest<CloudDocs.RenameResultSerializer, CloudDocs.RenameErrorSerializer> {
        let route = CloudDocs.rename
        let serverArgs = CloudDocs.RenameArg(fileId: fileId, title: title)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Unlock a Cloud Doc. This route requires Cloud Docs auth. Please make a request to cloud_docs/authorize and
    /// supply that token in the Authorization header.
    ///
    /// - parameter fileId: The API ID ("id:...") associated with the Cloud Doc
    ///
    ///  - returns: Through the response callback, the caller will receive a `CloudDocs.UnlockResult` object on success
    /// or a `CloudDocs.LockingError` object on failure.
    @discardableResult open func unlock(fileId: String = "") -> RpcRequest<CloudDocs.UnlockResultSerializer, CloudDocs.LockingErrorSerializer> {
        let route = CloudDocs.unlock
        let serverArgs = CloudDocs.UnlockArg(fileId: fileId)
        return client.request(route, serverArgs: serverArgs)
    }

    /// Update the contents of a Cloud Doc. This should be called for files with a max size of 150MB. This route
    /// requires Cloud Docs auth. Please make a request to cloud_docs/authorize and supply that token in the
    /// Authorization header.
    ///
    /// - parameter actorTokens: A list of auth_tokens, one for each editor who made changes to the document since the
    /// last call to update_content.
    /// - parameter additionalContents: Currently, this will always be empty until we implement
    /// upload_additional_content.
    /// - parameter input: The file to upload, as an Data object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `CloudDocs.UpdateContentResult` object on
    /// success or a `CloudDocs.UpdateContentError` object on failure.
    @discardableResult open func updateContent(fileId: String, actorTokens: Array<String>, additionalContents: Array<CloudDocs.Content>? = nil, input: Data) -> UploadRequest<CloudDocs.UpdateContentResultSerializer, CloudDocs.UpdateContentErrorSerializer> {
        let route = CloudDocs.updateContent
        let serverArgs = CloudDocs.UpdateContentArg(fileId: fileId, actorTokens: actorTokens, additionalContents: additionalContents)
        return client.request(route, serverArgs: serverArgs, input: .data(input))
    }

    /// Update the contents of a Cloud Doc. This should be called for files with a max size of 150MB. This route
    /// requires Cloud Docs auth. Please make a request to cloud_docs/authorize and supply that token in the
    /// Authorization header.
    ///
    /// - parameter actorTokens: A list of auth_tokens, one for each editor who made changes to the document since the
    /// last call to update_content.
    /// - parameter additionalContents: Currently, this will always be empty until we implement
    /// upload_additional_content.
    /// - parameter input: The file to upload, as an URL object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `CloudDocs.UpdateContentResult` object on
    /// success or a `CloudDocs.UpdateContentError` object on failure.
    @discardableResult open func updateContent(fileId: String, actorTokens: Array<String>, additionalContents: Array<CloudDocs.Content>? = nil, input: URL) -> UploadRequest<CloudDocs.UpdateContentResultSerializer, CloudDocs.UpdateContentErrorSerializer> {
        let route = CloudDocs.updateContent
        let serverArgs = CloudDocs.UpdateContentArg(fileId: fileId, actorTokens: actorTokens, additionalContents: additionalContents)
        return client.request(route, serverArgs: serverArgs, input: .file(input))
    }

    /// Update the contents of a Cloud Doc. This should be called for files with a max size of 150MB. This route
    /// requires Cloud Docs auth. Please make a request to cloud_docs/authorize and supply that token in the
    /// Authorization header.
    ///
    /// - parameter actorTokens: A list of auth_tokens, one for each editor who made changes to the document since the
    /// last call to update_content.
    /// - parameter additionalContents: Currently, this will always be empty until we implement
    /// upload_additional_content.
    /// - parameter input: The file to upload, as an InputStream object.
    ///
    ///  - returns: Through the response callback, the caller will receive a `CloudDocs.UpdateContentResult` object on
    /// success or a `CloudDocs.UpdateContentError` object on failure.
    @discardableResult open func updateContent(fileId: String, actorTokens: Array<String>, additionalContents: Array<CloudDocs.Content>? = nil, input: InputStream) -> UploadRequest<CloudDocs.UpdateContentResultSerializer, CloudDocs.UpdateContentErrorSerializer> {
        let route = CloudDocs.updateContent
        let serverArgs = CloudDocs.UpdateContentArg(fileId: fileId, actorTokens: actorTokens, additionalContents: additionalContents)
        return client.request(route, serverArgs: serverArgs, input: .stream(input))
    }

}
